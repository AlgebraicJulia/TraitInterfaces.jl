var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#Interfaces","page":"Library Reference","title":"Interfaces","text":"","category":"section"},{"location":"api/#TraitInterfaces.Interfaces.Algorithms.rename-Tuple{Interface, Dict{Symbol, Symbol}}","page":"Library Reference","title":"TraitInterfaces.Interfaces.Algorithms.rename","text":"This is boilerplate for the systematic renaming of types/operations in an  interface.\n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Interfaces.Algorithms.sortcheck-Tuple{Interface, TypeScope, AlgTerm}","page":"Library Reference","title":"TraitInterfaces.Interfaces.Algorithms.sortcheck","text":"Throw an error if a the head of an AlgTerm (which refers to a term constructor) has arguments of the wrong sort. Returns the sort of the term.\n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Interfaces.Syntax","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax","text":"The building blocks that make up an interface \n\n\n\n\n\n","category":"module"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.AlgAccessor","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.AlgAccessor","text":"AlgAccessor\n\nThe arguments to a type/term constructor serve a dual function as both arguments  and also methods to extract the value of those arguments.\n\nE.g. declaring Hom(dom::Ob, codom::Ob)::TYPE implicitly creates projection operations like dom(h::Hom)::Ob.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.AlgAxiom","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.AlgAxiom","text":"Declare two (context dependent) terms are equal \n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.AlgFunction","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.AlgFunction","text":"A term constructor which is purely derivative on other term constructors,  such as \"square(x) := x * x\" (where * is some other term constructor). One need not specify the implementation of such an operation when declaring an  implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.AlgSort","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.AlgSort","text":"AlgSort\n\nA sort, which is essentially a type constructor without arguments\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.AlgSort-Tuple{AlgType}","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.AlgSort","text":"A type constructor, alternatively thought of as a (possibly-dependent) type  where we have forgotten the arguments it depends on. E.g. given a type  Matrix{3,4} for 3 Ã— 4 matrices, the corresponding sort is Matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.AlgTerm","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.AlgTerm","text":"Subtyped by TermVar or TermApp \n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.Judgment","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.Judgment","text":"Judgments constitute the content of an interface \n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.TermApp","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.TermApp","text":"A term, which is a variable name (Symbol) in some context or the application  of an operation to some other terms.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.TermConstructor","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.TermConstructor","text":"Declare an operation \n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.TermVar","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.TermVar","text":"Reference something in the context by name\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.TrmTypConstructor","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.TrmTypConstructor","text":"Either a TypeConstructor or a TermConstructor \n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.TypeApp","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.TypeApp","text":"A (possibly dependent) type, represented as a type constructor applied to some  terms. The type can depend on some concrete data (terms) as well as some types.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.TypeConstructor","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.TypeConstructor","text":"Declare a type (possibly dependent on other types and terms) \n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.TypeScope","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.TypeScope","text":"A context that a term (or type) can live in. It has an (ordered) list of names  bound to types. Later types can refer to earlier types in the list.\n\nThe lookup field caches a quick way of getting the type from its name. There  are no name collisions allowed.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.VarArgType","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.VarArgType","text":"A type that is only allowed to be the last argument in a signature th \n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceData","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceData","text":"Defining the data structure which stores data of an interface \n\n\n\n\n\n","category":"module"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceData.Interface","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceData.Interface","text":"An interface has types, operations, and equations.\n\nThese may be abstract. An implementation provides concrete (Julia) types and  methods for any abstract types and operations in the theory.\n\nWe can ascribe aliases to various types or operations.\n\nOperations can be overloaded, meaning we can distinguish operations that have  the same name if they have different type signatures. This should be used with  caution, as implementations of the interface which assign the same concrete type  to distinct abstract types can then cause method ambiguities.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceData.Interface-Tuple{Symbol}","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceData.Interface","text":"Create an empty interface - just provide the name of the interface \n\n\n\n\n\n","category":"method"},{"location":"api/#Base.union!-Tuple{Interface, Interface}","page":"Library Reference","title":"Base.union!","text":"Combine judgments from two interfaces, removing duplicates \n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceData.allnames-Tuple{Interface}","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceData.allnames","text":"All type/term constructors as well as accessors \n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceData.lookup","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceData.lookup","text":"From a name, get a type or an operation.\n\nsorts not required unless there is overloading \n\n\n\n\n\n","category":"function"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.Dispatch","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.Dispatch","text":"The Dispatch implementation of an interface defers to type-dispatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.Trait","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.Trait","text":"Trait is a wrapper around a Julia value in order to signify it is being  treated as a trait, i.e. a Holy trait, to be used as the first parameter in  order to control dispatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.wrapper-Tuple{Symbol, Interface, Any}","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.wrapper","text":"Given an interface module, take a name (and an abstract type, optionally) and construct a type with that name which plays the role of wrapping a model of the interface.\n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.@interface-Tuple{Any, Any}","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.@interface","text":"Declare an interface (creates a module), possibly by extending an old one \n\n\n\n\n\n","category":"macro"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.@theory-Tuple{Any, Any}","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.@theory","text":"Same thing as @interface \n\n\n\n\n\n","category":"macro"},{"location":"api/#Implementations","page":"Library Reference","title":"Implementations","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [\n  TraitInterfaces.Implementations.Check,\n  TraitInterfaces.Implementations.ModelInterface,\n  TraitInterfaces.Implementations.SpecialModels,\n]","category":"page"},{"location":"generated/full_demo/#Full-Demo","page":"Full Demo","title":"Full Demo","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"using TraitInterfaces, Test","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"This is a self-contained walkthrough of the main features of TraitInterfaces. This is a regular julia file that can be run interactively.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Importantly:","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"use Julia 1.10\nactivate the environment in TraitInterfaces.jl/docs","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Table of contents:","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"...","category":"page"},{"location":"#TraitInterfaces.jl","page":"TraitInterfaces.jl","title":"TraitInterfaces.jl","text":"","category":"section"},{"location":"#Authors","page":"TraitInterfaces.jl","title":"Authors","text":"","category":"section"},{"location":"","page":"TraitInterfaces.jl","title":"TraitInterfaces.jl","text":"This documentation is maintained by Kristopher Brown.","category":"page"},{"location":"","page":"TraitInterfaces.jl","title":"TraitInterfaces.jl","text":"This package largely came from extracting pieces of GATlab.jl, developed by Owen Lynch and Kris Brown, based on Evan Patterson's original work on GATs (generalized algebraic theories) in Catlab. In this repo, the GAT aspects have been stripped away. Many projects in the AlgebraicJulia ecosystem rely on interfaces without using the understanding of interfaces as being the objects of category. GATlab will focus on this latter goal.","category":"page"}]
}
