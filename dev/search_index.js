var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#Interfaces","page":"Library Reference","title":"Interfaces","text":"","category":"section"},{"location":"api/#TraitInterfaces.Interfaces.Algorithms.rename-Tuple{Interface, Dict{Symbol, Symbol}}","page":"Library Reference","title":"TraitInterfaces.Interfaces.Algorithms.rename","text":"This is boilerplate for the systematic renaming of types/operations in an  interface.\n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Interfaces.Algorithms.sortcheck-Tuple{Interface, TypeScope, AlgTerm}","page":"Library Reference","title":"TraitInterfaces.Interfaces.Algorithms.sortcheck","text":"Throw an error if a the head of an AlgTerm (which refers to a term constructor) has arguments of the wrong sort. Returns the sort of the term.\n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Interfaces.Syntax","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax","text":"The building blocks that make up an interface \n\n\n\n\n\n","category":"module"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.AlgAccessor","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.AlgAccessor","text":"AlgAccessor\n\nThe arguments to a type/term constructor serve a dual function as both arguments  and also methods to extract the value of those arguments.\n\nE.g. declaring Hom(dom::Ob, codom::Ob)::TYPE implicitly creates projection operations like dom(h::Hom)::Ob.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.AlgAxiom","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.AlgAxiom","text":"Declare two (context dependent) terms are equal \n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.AlgFunction","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.AlgFunction","text":"A term constructor which is purely derivative on other term constructors,  such as \"square(x) := x * x\" (where * is some other term constructor). One need not specify the implementation of such an operation when declaring an  implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.AlgSort","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.AlgSort","text":"AlgSort\n\nA sort, which is essentially a type constructor without arguments\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.AlgSort-Tuple{AlgType}","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.AlgSort","text":"A type constructor, alternatively thought of as a (possibly-dependent) type  where we have forgotten the arguments it depends on. E.g. given a type  Matrix{3,4} for 3 × 4 matrices, the corresponding sort is Matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.AlgTerm","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.AlgTerm","text":"Subtyped by TermVar or TermApp \n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.Judgment","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.Judgment","text":"Judgments constitute the content of an interface \n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.TermApp","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.TermApp","text":"A term, which is a variable name (Symbol) in some context or the application  of an operation to some other terms.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.TermConstructor","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.TermConstructor","text":"Declare an operation \n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.TermVar","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.TermVar","text":"Reference something in the context by name\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.TrmTypConstructor","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.TrmTypConstructor","text":"Either a TypeConstructor or a TermConstructor \n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.TypeApp","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.TypeApp","text":"A (possibly dependent) type, represented as a type constructor applied to some  terms. The type can depend on some concrete data (terms) as well as some types.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.TypeConstructor","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.TypeConstructor","text":"Declare a type (possibly dependent on other types and terms) \n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.TypeScope","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.TypeScope","text":"A context that a term (or type) can live in. It has an (ordered) list of names  bound to types. Later types can refer to earlier types in the list.\n\nThe lookup field caches a quick way of getting the type from its name. There  are no name collisions allowed.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.Syntax.VarArgType","page":"Library Reference","title":"TraitInterfaces.Interfaces.Syntax.VarArgType","text":"A type that is only allowed to be the last argument in a signature th \n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceData","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceData","text":"Defining the data structure which stores data of an interface \n\n\n\n\n\n","category":"module"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceData.Interface","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceData.Interface","text":"An interface has types, operations, and equations.\n\nThese may be abstract. An implementation provides concrete (Julia) types and  methods for any abstract types and operations in the theory.\n\nWe can ascribe aliases to various types or operations.\n\nOperations can be overloaded, meaning we can distinguish operations that have  the same name if they have different type signatures. This should be used with  caution, as implementations of the interface which assign the same concrete type  to distinct abstract types can then cause method ambiguities.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceData.Interface-Tuple{Symbol}","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceData.Interface","text":"Create an empty interface - just provide the name of the interface \n\n\n\n\n\n","category":"method"},{"location":"api/#Base.union!-Tuple{Interface, Interface}","page":"Library Reference","title":"Base.union!","text":"Combine judgments from two interfaces, removing duplicates \n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceData.allnames-Tuple{Interface}","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceData.allnames","text":"All type/term constructors as well as accessors \n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceData.lookup","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceData.lookup","text":"From a name, get a type or an operation.\n\nsorts not required unless there is overloading \n\n\n\n\n\n","category":"function"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.Dispatch","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.Dispatch","text":"The Dispatch implementation of an interface defers to type-dispatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.InitialModel′","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.InitialModel′","text":"The Initial model assigns Union{} to all AlgSorts. There is one implementation for any given theory.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.TerminalModel′","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.TerminalModel′","text":"The Terminal model assigns Nothing to all AlgSorts. There is one  implementation for any given theory.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.Trait","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.Trait","text":"Trait is a wrapper around a Julia value in order to signify it is being  treated as a trait, i.e. a Holy trait, to be used as the first parameter in  order to control dispatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.wrapper-Tuple{Symbol, Interface, Any}","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.wrapper","text":"Given an interface module, take a name (and an abstract type, optionally) and construct a type with that name which plays the role of wrapping a model of the interface.\n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.@interface-Tuple{Any, Any}","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.@interface","text":"Declare an interface (creates a module), possibly by extending an old one \n\n\n\n\n\n","category":"macro"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.@theory-Tuple{Any, Any}","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.@theory","text":"Same thing as @interface \n\n\n\n\n\n","category":"macro"},{"location":"api/#Implementations","page":"Library Reference","title":"Implementations","text":"","category":"section"},{"location":"api/#TraitInterfaces.Implementations.Check","page":"Library Reference","title":"TraitInterfaces.Implementations.Check","text":"Runtime checking of method table to see if a trait has implemented a  particular interface \n\n\n\n\n\n","category":"module"},{"location":"api/#TraitInterfaces.Implementations.Check.impl_types-Tuple{Any, Module}","page":"Library Reference","title":"TraitInterfaces.Implementations.Check.impl_types","text":"If m implements a GAT with a type constructor (identified by ident id),  mapped to a Julia type, this function returns that Julia type.\n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.implements","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.implements","text":"Check whether a model implements a particular theory.\n\nIf no types are provided, then we look up whether or not impl_type methods  exist for this model + theory. If not, we will get a MethodError and assume  that the model does not implement the theory. (WARNING: occasionally one has  a complex type, such as foo(Int,String) which itself leads to a MethodError,  and this can be confusing because it looks like the model doesn't implement the theory at all rather than just being an error in how it was implemented).\n\nOnce types are provided, we can check whether the theory is implemented by  checking for each term constructor whether or not the model implements that (handled by a different implements method).\n\n\n\n\n\n","category":"function"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.implements-Tuple{Any, Module, Symbol, Vector{<:Type}, Vector{<:Type}}","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.implements","text":"Machine-friendly access to checking if a model implements a particular operation. The types vector is in bijection with the AlgSorts of the whole theory. \n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Interfaces.InterfaceModules.implements-Union{Tuple{T}, Tuple{T, Module, Symbol}, Tuple{T, Module, Symbol, Any}} where T","page":"Library Reference","title":"TraitInterfaces.Interfaces.InterfaceModules.implements","text":"User-friendly access to checking if a model implements an operation.\n\nThrows an error if the name is overloaded. Anything programmatic should be  calling a method which accepts method Idents rather than Symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Implementations.ModelInterface","page":"Library Reference","title":"TraitInterfaces.Implementations.ModelInterface","text":"Any Julia value can be a trait which implements an interface, I. A trait  t::T is considered to be implementing I iff, for all operations in I f(::A,::B,...), we have hasmethod(f, (Trait{M}, A, B)) == true. \n\n\n\n\n\n","category":"module"},{"location":"api/#TraitInterfaces.Implementations.ModelInterface.MissingMethodImplementation","page":"Library Reference","title":"TraitInterfaces.Implementations.ModelInterface.MissingMethodImplementation","text":"An error to throw when an implementation of an interface fails to implement a  particular method\n\n\n\n\n\n","category":"type"},{"location":"api/#TraitInterfaces.Implementations.ModelInterface.get_judgment_runtime-NTuple{6, Any}","page":"Library Reference","title":"TraitInterfaces.Implementations.ModelInterface.get_judgment_runtime","text":"We need to look at the method after having forgotten the dependent types and still be able to tell what method was being implemented. Ambiguity can arise. Check there is only one possibility given the sorts provided.\n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Implementations.ModelInterface.impl_type_declaration-NTuple{5, Any}","page":"Library Reference","title":"TraitInterfaces.Implementations.ModelInterface.impl_type_declaration","text":"Register the concrete Julia type associated with a given interface, type in that interface, and model which implements that type.\n\nE.g. if the interface ThCategory has a type Ob then \n\n@instance ThCategory{Ob=Foo, Hom=Bar} [model::Baz] should generate the  following code:\n\nimpl_type(::Baz, ThCategory.Ob) = Foo\n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Implementations.ModelInterface.parse_instance_body-Tuple{Expr}","page":"Library Reference","title":"TraitInterfaces.Implementations.ModelInterface.parse_instance_body","text":"Parses a raw julia block expression in @instance into JuliaFunctions \n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Implementations.ModelInterface.qualify_function-Tuple{TraitInterfaces.MetaUtils.JuliaFunction, Any, Union{Nothing, Expr, Symbol}, Any}","page":"Library Reference","title":"TraitInterfaces.Implementations.ModelInterface.qualify_function","text":"Does some preprocessing on the user-written method:\n\nAdd Trait param first (it shouldn't have it already). \nqualify method name to be in theory module.\n\nIf an interface ThCategory with operation id(x::Ob)::Hom is implemented via:\n\n@instance ThCategory{Ob=Foo, Hom=Bar} [model::Baz] begin \n  id(x::Foo)::Bar = ...\nend\n\n... then we syntactically modify this method to be:\n\nThCategory.id(model::Trait{<:Bar}, x::Foo) = ...\n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Implementations.ModelInterface.typecheck_runtime-NTuple{6, Any}","page":"Library Reference","title":"TraitInterfaces.Implementations.ModelInterface.typecheck_runtime","text":"Check that an instance properly implements some interface method.\n\nE.g. if the interface ThCategory has a method compose(f::Hom, g::Hom)\n\nthen @instance ThCategory{Ob=Foo, Hom=Bar} [model::Baz] should generate the  following code, to throw an error if the body of the macro didn't provide a  method of the expected type:\n\nhasmethod(ThCategory.compose, (Trait{<:Baz}, Bar, Bar)) || throw(\n  MissingMethodImplementation(...))\n\n\n\n\n\n","category":"method"},{"location":"api/#TraitInterfaces.Implementations.ModelInterface.@instance-Tuple{Any, Any, Any}","page":"Library Reference","title":"TraitInterfaces.Implementations.ModelInterface.@instance","text":"Usage: (TODO)\n\n\n\n\n\n","category":"macro"},{"location":"api/#TraitInterfaces.Implementations.ModelInterface.@withmodel-Tuple{Any, Any, Any}","page":"Library Reference","title":"TraitInterfaces.Implementations.ModelInterface.@withmodel","text":"Automatically add Trait trait parameter to some specified methods in a  code block.\n\n\n\n\n\n","category":"macro"},{"location":"api/#TraitInterfaces.Implementations.SpecialModels","page":"Library Reference","title":"TraitInterfaces.Implementations.SpecialModels","text":"Any interface can be implemented in some canonical ways: \n\nJust using dispatch\nAssigning all types in the interface the empty (Union{}) type\nAssigning all types in the interface the singleton (Nothing) type\n\n\n\n\n\n","category":"module"},{"location":"api/#TraitInterfaces.Implementations.SpecialModels.InitialModel","page":"Library Reference","title":"TraitInterfaces.Implementations.SpecialModels.InitialModel","text":"The unique term of type InitialModel′ \n\n\n\n\n\n","category":"constant"},{"location":"api/#TraitInterfaces.Implementations.SpecialModels.TerminalModel","page":"Library Reference","title":"TraitInterfaces.Implementations.SpecialModels.TerminalModel","text":"The unique term of type TerminalModel′ \n\n\n\n\n\n","category":"constant"},{"location":"generated/full_demo/#Full-Demo","page":"Full Demo","title":"Full Demo","text":"","category":"section"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"using TraitInterfaces, Test","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"This is a self-contained walkthrough of the main features of TraitInterfaces. This is a regular julia file that can be run interactively.","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Importantly:","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"use Julia 1.10\nactivate the environment in TraitInterfaces.jl/docs","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"Table of contents:","category":"page"},{"location":"generated/full_demo/","page":"Full Demo","title":"Full Demo","text":"...","category":"page"},{"location":"#TraitInterfaces.jl","page":"TraitInterfaces.jl","title":"TraitInterfaces.jl","text":"","category":"section"},{"location":"#Authors","page":"TraitInterfaces.jl","title":"Authors","text":"","category":"section"},{"location":"","page":"TraitInterfaces.jl","title":"TraitInterfaces.jl","text":"This documentation is maintained by Kristopher Brown.","category":"page"},{"location":"","page":"TraitInterfaces.jl","title":"TraitInterfaces.jl","text":"This package largely came from extracting pieces of GATlab.jl, developed by Owen Lynch and Kris Brown, based on Evan Patterson's original work on GATs (generalized algebraic theories) in Catlab. In this repo, the GAT aspects have been stripped away. Many projects in the AlgebraicJulia ecosystem rely on interfaces without using the understanding of interfaces as being the objects of category. GATlab will focus on this latter goal.","category":"page"}]
}
